namespace MonkeyLangInterpreter
{
    /// <summary>
    /// Class for containing all datat types associated with the Abstract Syntax Tree generated by the <see cref="Lexer"/>
    /// </summary>
    internal class AST
    {
        /// <summary>
        /// Base interface for the abstract syntax tree. 
        /// forces the implementation of <see cref="TokenLiteral"/>
        /// </summary>
        public interface INode
        {
            /// <summary>
            /// Returns the associated Literal value for the nodes <see cref="Token"/>.
            /// </summary>
            /// <returns>A string containing the associated literal for this nodes token</returns>
            public string TokenLiteral();
        }

        /// <summary>
        /// The interface for all statements forces the implementation of <see cref="String"/>
        /// </summary>
        public interface IStatement : INode
        {
            /// <summary>
            /// Return a string containing all associated data for a statement.
            /// </summary>
            /// <returns>String containing all data associated with this statement</returns>
            public string String();
        }

        /// <summary>
        /// The interface for all expressions inherits  
        /// <see cref="IStatement"/> and
        /// <see cref="INode"/>
        /// </summary>
        public interface IExpression : IStatement, INode
        {

        }

        internal struct Program : INode
        {
            public IStatement[] Statements;

            /// <summary>
            /// Gets the statements combined into a single string
            /// </summary>
            /// <returns>A string containing all child statement string concatenated together</returns>
            public string String()
            {
                string s = "";
                foreach (IStatement statement in Statements)
                {
                    s += statement.String();
                }
                return s;
            }

            /// <summary>
            /// Returns the literal value of the token assoc. with this element.
            /// As this is a program, which does not contain a single node, it returns a 
            /// Default value of PROGRAM_NODE
            /// </summary>
            /// <returns>A default string ("PROGRAM_NODE")</returns>
            public string TokenLiteral()
            {
                return "PROGRAM_NODE";
            }
        }

        public struct Identifier : IStatement, IExpression
        {
            public Token Token;
            public string Value;


            public string String()
            {
                return Value;
            }

            public string TokenLiteral()
            {
                return Token.Literal;
            }
        }

        internal struct LetStatement : IStatement
        {
            public Token Token;
            public Identifier Name;
            public IExpression Value;
            public string TokenLiteral()
            {
                return Token.Literal;
            }

            public string String()
            {
                string s = TokenLiteral() + " " + Name.String() + " = ";
                if (Value != null)
                {
                    s += Value.String();
                }
                s += ";";
                return s;
            }
        }

        internal struct ReturnStatement : IStatement
        {
            public Token Token;
            public IExpression ReturnValue;

            public string TokenLiteral()
            {
                return Token.Literal;
            }

            public string String()
            {
                string s = TokenLiteral() + " ";
                if (ReturnValue != null)
                {
                    s += ReturnValue.String();
                }
                s += ";";
                return s;
            }

        }

        internal struct ExpressionStatement : IStatement
        {
            public Token Token;
            public IExpression Expression;

            public string String()
            {
                return Expression.String();
            }

            public string TokenLiteral()
            {
                return Token.Literal;
            }
        }

        internal struct IntegerLiteral : IExpression
        {
            public Token Token;
            public long Value;
            public string String()
            {
                return Token.Literal;
            }

            public string TokenLiteral()
            {
                return Token.Literal;
            }
        }

        internal struct InfixExpression : IExpression
        {
            public Token Token;
            public IExpression Left;
            public string Operator;
            public IExpression Right;

            public string String()
            {
                return $"({Left.String()} {Operator} {Right.String()})";
            }

            public string TokenLiteral()
            {
                return Token.Literal;
            }
        }

        internal struct PrefixExpression : IExpression
        {
            public Token Token;
            public string Operator;
            public IExpression Right;

            public string String()
            {
                return $"({Operator}{Right.String()})";
            }

            public string TokenLiteral()
            {
                return Token.Literal;
            }
        }

        internal struct Boolean : IExpression
        {
            public Token Token;
            public bool Value;

            public string String()
            {
                return Token.Literal;
            }

            public string TokenLiteral()
            {
                return Token.Literal;
            }
        }

        internal struct IfExpression : IExpression
        {
            public Token Token;
            public IExpression Condition;
            public BlockStatement? Consequence;
            public BlockStatement? Alternative;

            public string String()
            {
                string s = "";
                s += "if" + Condition.String() + " " + Consequence.Value.String();
                if (Alternative != null)
                {
                    s += "else " + Alternative.Value.String();
                }
                return s;
            }

            public string TokenLiteral()
            {
                return Token.Literal;
            }
        }

        internal struct BlockStatement : IStatement
        {
            public Token Token;
            public IStatement[] Statements;

            public string String()
            {
                string s = "";
                foreach (IStatement statement in Statements)
                {
                    s += statement.String();
                }
                return s;
            }

            public string TokenLiteral()
            {
                return Token.Literal;
            }
        }

        internal struct FunctionLiteral : IExpression
        {
            public Token Token;
            public Identifier[] Parameters;
            public BlockStatement Body;

            public string String()
            {
                string s = "";
                List<string> strings = new();
                foreach (Identifier p in Parameters)
                {
                    strings.Add(p.String());
                }
                s += TokenLiteral() + "(" + string.Join(",", strings.Select(x => x.ToString()).ToArray()) + ") " + Body.String();
                return s;
            }

            public string TokenLiteral()
            {
                return Token.Literal;
            }
        }

        internal struct CallExpression : IExpression
        {
            public Token Token;
            public IExpression Function;
            public IExpression[] Arguments;

            public string String()
            {
                string s = "";
                List<string> strings = new();
                foreach (IExpression p in Arguments)
                {
                    strings.Add(p.String());
                }
                s += Function.String() + "(" + string.Join(", ", strings.Select(x => x.ToString()).ToArray()) + ")";
                return s;
            }

            public string TokenLiteral()
            {
                return Token.Literal;
            }
        }

        internal struct StringLiteral : IExpression
        {
            public Token Token;
            public string Value;

            public string String()
            {
                return Token.Literal;
            }

            public string TokenLiteral()
            {
                return Token.Literal;
            }
        }

        internal struct ArrayLiteral : IExpression
        {
            public Token Token;
            public IExpression[] Elements;

            public string String()
            {
                string s = "";
                List<string> strings = new();
                foreach (IExpression p in Elements)
                {
                    strings.Add(p.String());
                }
                s += "[" + string.Join(",", strings.Select(x => x.ToString()).ToArray()) + "] ";
                return s;
            }

            public string TokenLiteral()
            {
                return Token.Literal;
            }
        }

        internal struct IndexExpression : IExpression
        {
            public Token Token;
            public IExpression Left;
            public IExpression Index;

            public string String()
            {
                string s = "(" + Left.String() + "[" + Index.String() + "])";
                return s;
            }

            public string TokenLiteral()
            {
                return Token.Literal;
            }
        }

        internal struct HashLiteral : IExpression
        {
            //public Token Token;
            public Dictionary<IExpression, IExpression> Pairs;

            public string String()
            {
                List<string> list = new();
                foreach (KeyValuePair<IExpression, IExpression> pair in Pairs)
                {
                    list.Add(pair.Key.String() + " " + pair.Value.String());
                }
                return "{" + string.Join(", ", list.Select(x => x.ToString()).ToArray()) + "}";

            }

            public string TokenLiteral()
            {
                return "HASH";
            }
        }

    }
}
